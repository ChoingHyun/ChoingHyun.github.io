---
layout:     post
title:      "Android NDK 环境搭建以及初探"
subtitle:   ""
date:       2015-10-28
author:     "Eric"
header-img: "img/post-bg-js-module.jpg"
tags:
    - Android
    - NDK
---
在搭NDK环境的时候，参考了网上其他资料，在过程中踩到一些坑。总的流程如下：
**1.NDK的下载与环境变量的配置。**
笔者实在Mac上进行实践的，在环境变量上也走了一点弯路。
mac 配置环境变量，有三种不同级别的环境变量，NDK的配置使用第三种
1./etc/profile 全局（公有）配置，不管是哪个用户，登录时都会读取该文件。
2./etc/bashrc  全局（公有）配置，bash shell执行时，不管是何种方式，都会读取此文件。
3.~/.bash_profile  一般在这个文件中添加**用户级**环境变量（注：Linux 里面是 .bashrc 而 Mac 是 .bash_profile）
如果想立刻生效，则可执行下面的语句：
$ source .bash_profile（这是文件名）
这是笔者的环境变量配置，供参考，一个是Android的，一个是NDK的

	export PATH="$PATH:/Users/changhuiyuan/Library/Android/sdk/platform-tools"
	export NDK_ROOT="/Users/changhuiyuan/Documents/Android/android-ndk-r10e"
	export PATH="$PATH:$NDK_ROOT"

备注：在配置过程中，注意检查拼写，以及使用引文引号，同时确保路径的完整性。
配置完成，在终端中输入*ndk-make*指令进行测试，出现以下内容则证明环境变量配置正确：

	Android NDK: Could not find application project directory !    
	Android NDK: Please define the NDK_PROJECT_PATH variable to point to it.    
	/Users/changhuiyuan/Documents/Android/android-ndk-r10e/build/core/build-	local.mk:143: *** Android NDK: Aborting    .  Stop.
	
**2.编写带native方法的Java类，编译为字节码**

	package cn.edu.zju.chy.jni;

	public class JNI {
    public native int add(int a, int b);
	static {
        System.loadLibrary("app");//导入生成的链接库文件
    }


使用javac命令对带有native方法的类进行编译，得到.class的字节码文件
使用javah命令生成一个.h的头文件，如下所示：

	/* DO NOT EDIT THIS FILE - it is machine generated */
	#include <jni.h>
	/* Header for class cn_edu_zju_chy_jni_JNI */

	#ifndef _Included_cn_edu_zju_chy_jni_JNI
	#define _Included_cn_edu_zju_chy_jni_JNI
	#ifdef __cplusplus
	extern "C" {
	#endif
	/*
 	* Class:     cn_edu_zju_chy_jni_JNI
 	* Method:    add
 	* Signature: (II)I
 	*/
	JNIEXPORT jint JNICALL Java_cn_edu_zju_chy_jni_JNI_add
	  (JNIEnv *, jobject, jint, jint);

	#ifdef __cplusplus
	}
	#endif
	#endif
	
在项目main路径下，创建jni目录，将头文件拷贝到jni下。同时，设置工程的NDK路径：File-Project Structure。
**3.实现头文件**
头文件的实现较为简单，需要注意include的头文件

	#include <string.h>
	#include <jni.h>
	#include <cn_edu_zju_chy_jni_JNI.h>

	#define width 2752/6
	#define height 2208/6

	JNIEXPORT jint JNICALL Java_cn_edu_zju_chy_jni_JNI_add
        (JNIEnv *jniEnv, jobject object, jint a, jint b) {
    int test_z;
    int test_j;
    int test_i;
    int times = 0;
    int useless = 0;
    int pic[width][height] = {0};
    for (test_z = 0; test_z < 600; test_z++) {
        for (test_j = 0; test_j < height; test_j++) {
            for (test_i = 0; test_i < width; test_i++) {
                times ++;
                pic[test_i][test_j] += test_i * test_j + test_z;
            }
  	      }
  	  }
    return times;
	}

**4.编写makefile文件**
ndk中一共需要两个makefile文件需要编写：Android.mk与Application.mk
*Android.mk*包含了与编译c文件的路径、生成文件的名称等信息，如下：

	LOCAL_PATH := $(call my-dir)
	include $(CLEAR_VARS)
	LOCAL_MODULE := jni
	LOCAL_SRC_FILES :=source/cn_edu_zju_chy_jni_JNI.c
	include $(BUILD_SHARED_LIBRARY)
	
*Application.mk*包含了针对不同运行平台的配置等信息，如下：

	# $Id: Application.mk 212 2015-05-15 10:22:36Z oparviai $
	#
	# Build library bilaries for all supported architectures
	#
	APP_ABI := armeabi armeabi-v7a x86 mips
	APP_OPTIM := release
	APP_STL := stlport_static
	#APP_CPPFLAGS := -fexceptions # -D SOUNDTOUCH_DISABLE_X86_OPTIMIZATIONS

**5.ndk-build**
在项目中，通过终端进入项目中jni目录的父目录，执行*ndk-build*命令，若没有语法错误，会在libs下面生成针对不同平台的.so动态连接库文件。大功告成！此时，工程结构如下：
![demo](http://7xn8ba.com1.z0.glb.clouddn.com/demo.png?imageView2/2/h/540))
**6.运行**
gradle.property 中添加：android.useDeprecatedNdk=true
RUN~
<a href="https://github.com/ChoingHyun/NDK-Simple-Demo" target="_blank">源码</a>
**7.说明**
如果在java类中添加了native声明的方法，需要重新进行javac，javah重新生成头文件，重新实现，也就是从步骤2重新开始。
如果只是修改c方法内的实现，只需要执行第五步，重新make生成新的.so后，即可运行。



















